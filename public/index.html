<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Racing Telemetry Dashboard</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
    <div class="batik-pattern"></div>
    <div class="container">

        <nav class="dashboard-nav">
            <button class="nav-button active" onclick="showTab('cards')" data-tab="cards">
                <span class="nav-icon">üìä</span>
                <span class="nav-text">Cards</span>
            </button>
            <button class="nav-button" onclick="showTab('charts')" data-tab="charts">
                <span class="nav-icon">üìà</span>
                <span class="nav-text">Charts</span>
            </button>
            <button class="nav-button" onclick="showTab('table')" data-tab="table">
                <span class="nav-icon">üìã</span>
                <span class="nav-text">Data Table</span>
            </button>
               <div class="connection-status">
                    <span id="status-indicator" class="status-dot offline">‚óè</span>
                    <span id="status-text" class="status-label">Offline</span>
                </div>
        </nav>

        <!-- Cards Tab -->
        <div id="cards-tab" class="tab-content active">
            <div id="cards-container"></div>
        </div>

        <!-- Charts Tab -->
        <div id="charts-tab" class="tab-content">
            <div id="charts-container"></div>
        </div>

        <!-- Table Tab -->
        <div id="table-tab" class="tab-content">
            <div class="table-actions">
                <button id="export-pdf" class="export-btn">
                    <span>üìÑ</span> Export PDF
                </button>
                <button id="export-csv" class="export-btn">
                    <span>üìä</span> Export CSV
                </button>
            </div>
            <div class="table-container">
                <table id="data-table" class="telemetry-table">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Device ID</th>
                            <th>Lap</th>
                            <th>RPM</th>
                            <th>Temperature (¬∞C)</th>
                            <th>AFR</th>
                            <th>TPS (%)</th>
                            <th>MAP (kPa)</th>
                            <th>Incline (¬∞)</th>
                            <th>Stroke (mm)</th>
                            <th>Speed (km/h)</th>
                            <th>Latitude</th>
                            <th>Longitude</th>
                            <th>Satellites</th>
                            <th>AI Classification</th>
                            <th>Cooling Active</th>
                            <th>Fan On</th>
                            <th>Current Temp (¬∞C)</th>
                            <th>Free Heap</th>
                            <th>Uptime</th>
                            <th>WiFi RSSI</th>
                        </tr>
                    </thead>
                    <tbody id="table-body">
                        <!-- Data rows will be inserted here (newest first) -->
                    </tbody>
                </table>
            </div>
        </div>

        <footer class="dashboard-footer">
            <div class="footer-stats">
                <div class="footer-item">
                    <span class="footer-label">Last Update:</span>
                    <span id="last-update" class="footer-value">Never</span>
                </div>
                <div class="footer-item">
                    <span class="footer-label">Total Records:</span>
                    <span id="total-records" class="footer-value">0</span>
                </div>
            </div>
        </footer>
    </div>

    <script src="cards.js"></script>
    <script src="charts.js"></script>
    <script>
// ============================================================================
// GLOBAL VARIABLES & INITIALIZATION  
// ============================================================================

// Socket.IO connection
const socket = io();

// Qt WebChannel integration - FORCE ACTIVE
let qtBridge = null;
let isQtIntegration = true; // FORCE TRUE - ALWAYS QT MODE

// Global state
let isConnected = false;
let allTelemetryData = [];

// FORCE Qt integration mode
console.log('üöÄ Running in Qt Integration Mode (Force Activated)');

// ============================================================================
// Qt WebChannel Integration (Enhanced)
// ============================================================================

// Enhanced Qt integration detection
function checkQtIntegration() {
    const detectionMethods = {
        forceFlag: true,
        windowFlag: window.isQtIntegration === true,
        qtEnvironment: typeof qt !== 'undefined',
        webChannelAvailable: typeof QWebChannel !== 'undefined',
        transportAvailable: typeof qt !== 'undefined' && qt.webChannelTransport
    };
    
    console.log('=== Qt Integration Detection ===');
    Object.entries(detectionMethods).forEach(([key, value]) => {
        console.log(`- ${key}:`, value);
    });
    
    isQtIntegration = Object.values(detectionMethods).some(Boolean);
    console.log('‚úÖ Final Qt Integration Status:', isQtIntegration);
    
    return isQtIntegration;
}

// Initialize Qt bridge when available
function initQtBridge() {
    console.log('üîÑ Initializing Qt Bridge...');
    
    if (typeof qt === 'undefined') {
        console.error('‚ùå qt object not available');
        return;
    }
    
    if (!qt.webChannelTransport) {
        console.error('‚ùå qt.webChannelTransport not available');
        return;
    }
    
    if (typeof QWebChannel === 'undefined') {
        console.error('‚ùå QWebChannel not available, attempting to load...');
        loadQWebChannelScript();
        return;
    }
    
    try {
        new QWebChannel(qt.webChannelTransport, function (channel) {
            console.log('‚úÖ QWebChannel connected successfully');
            console.log('üìã Available objects:', Object.keys(channel.objects));
            
            qtBridge = channel.objects.qtBridge;
            
            if (qtBridge) {
                console.log('‚úÖ qtBridge object connected successfully');
                
                // Test connection
                qtBridge.logMessage('üéØ JavaScript Force Mode - Successfully Connected to Qt');
                
                // Setup Qt-specific functionality
                setupQtExports();
                setupQtEventHandlers();
                
                // Update connection status
                updateConnectionStatus(true);
                
                // Request initial data
                if (qtBridge.requestTelemetryData) {
                    console.log('üì° Requesting initial telemetry data...');
                    qtBridge.requestTelemetryData();
                }
                
            } else {
                console.error('‚ùå qtBridge object not found in channel.objects');
                console.log('Available objects:', channel.objects);
            }
        });
    } catch (error) {
        console.error('‚ùå Error initializing QWebChannel:', error);
    }
}

// Dynamically load QWebChannel script
function loadQWebChannelScript() {
    console.log('üì• Loading QWebChannel script dynamically...');
    const script = document.createElement('script');
    script.src = 'qrc:///qtwebchannel/qwebchannel.js';
    script.onload = function() {
        console.log('‚úÖ QWebChannel script loaded successfully');
        setTimeout(initQtBridge, 500);
    };
    script.onerror = function() {
        console.error('‚ùå Failed to load QWebChannel script');
    };
    document.head.appendChild(script);
}

// Setup Qt-specific export functions
function setupQtExports() {
    if (!qtBridge) return;
    
    console.log('‚öôÔ∏è Setting up Qt export functions...');
    
    // Override export functions for Qt integration
    window.exportToPDF = function() {
        console.log('üìÑ PDF Export triggered via Qt override');
        if (allTelemetryData.length === 0) {
            alert('‚ö†Ô∏è No data available for export');
            return;
        }
        generatePDFForQt();
    };
    
    window.exportToCSV = function() {
        console.log('üìä CSV Export triggered via Qt override');
        if (allTelemetryData.length === 0) {
            alert('‚ö†Ô∏è No data available for export');
            return;
        }
        generateCSVForQt();
    };
    
    console.log('‚úÖ Qt export functions setup complete');
}

// Setup Qt event handlers
function setupQtEventHandlers() {
    if (!qtBridge) return;
    
    console.log('üîó Setting up Qt event handlers...');
    
    // Connect to Qt signals
    if (qtBridge.dataUpdated) {
        qtBridge.dataUpdated.connect(function() {
            console.log('üì° Data updated signal received from Qt');
            requestDataFromQt();
        });
        console.log('‚úÖ dataUpdated signal connected');
    }
    
    // Listen for telemetry data from Qt
    if (qtBridge.telemetryDataReady) {
        qtBridge.telemetryDataReady.connect(function(jsonData) {
            console.log('üìä Telemetry data received from Qt:', jsonData ? jsonData.length : 0, 'characters');
            updateTelemetryDataFromQt(jsonData);
        });
        console.log('‚úÖ telemetryDataReady signal connected');
    }
    
    console.log('‚úÖ Qt event handlers setup complete');
}

// Request data from Qt
function requestDataFromQt() {
    if (qtBridge && qtBridge.requestTelemetryData) {
        console.log('üì° Requesting telemetry data from Qt...');
        qtBridge.requestTelemetryData();
    }
}

// Generate PDF for Qt integration - NEWEST FIRST
function generatePDFForQt() {
    try {
        console.log('üìÑ Generating PDF for Qt...');
        
        if (!window.jsPDF) {
            console.error('‚ùå jsPDF library not available');
            return;
        }
        
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('l', 'mm', 'a4');
        
        // Add title with Qt integration styling
        doc.setFontSize(20);
        doc.setTextColor(0, 150, 200);
        doc.text('Racing Telemetry Data Report', 14, 22);
        doc.setTextColor(0, 0, 0);
        
        // Add generation info
        doc.setFontSize(10);
        doc.text('Generated via Qt WebEngine Integration', 14, 30);
        doc.text('Generated on: ' + new Date().toLocaleString(), 14, 35);
        doc.text('Total Records: ' + allTelemetryData.length, 14, 40);
        doc.text('Data Order: Newest First', 14, 45);
        
        // Prepare table data
        const columns = [
            'Timestamp', 'Device', 'Lap', 'RPM', 'Temp', 'AFR', 'TPS', 'MAP', 
            'Incline', 'Stroke', 'Speed', 'Lat', 'Lng', 'Sat', 'AI Class', 
            'Cooling', 'Fan', 'C.Temp', 'Heap', 'Uptime', 'RSSI'
        ];
        
        // REVERSE data order - newest first
        const reversedData = allTelemetryData.slice().reverse();
        const rows = reversedData.slice(0, 1000).map(data => [
            new Date(data.timestamp || Date.now()).toLocaleString(),
            data.device_id || 'ESP32-001',
            data.lap_number || '1',
            data.sensors?.rpm || '0',
            data.sensors?.temperature || '0',
            data.sensors?.afr || '14.7',
            data.sensors?.tps || '0',
            data.sensors?.map_value || '101.3',
            data.sensors?.incline || '0',
            data.sensors?.stroke || '0',
            data.gps?.speed || '0',
            data.gps?.latitude || '0',
            data.gps?.longitude || '0',
            data.gps?.satellites || '8',
            data.ai_classification?.classification_text || 'Normal',
            data.cooling?.system_active ? 'Yes' : 'No',
            data.cooling?.fan_on ? 'Yes' : 'No',
            data.cooling?.current_temp || '0',
            formatBytes(data.system_health?.free_heap) || '50KB',
            formatUptime(data.system_health?.uptime) || '0h 0m',
            data.system_health?.wifi_rssi || '-45'
        ]);
        
        // Add table if autoTable is available
        if (doc.autoTable) {
            doc.autoTable({
                head: [columns],
                body: rows,
                startY: 50,
                styles: { 
                    fontSize: 6,
                    cellPadding: 2
                },
                headStyles: { 
                    fillColor: [0, 150, 200],
                    textColor: [255, 255, 255],
                    fontStyle: 'bold'
                },
                alternateRowStyles: {
                    fillColor: [240, 248, 255]
                },
                theme: 'striped'
            });
        }
        
        // Get base64 and trigger Qt download
        const pdfBase64 = doc.output('datauristring').split(',')[1];
        
        if (qtBridge && qtBridge.downloadPDF) {
            console.log('üì§ Sending PDF to Qt, length:', pdfBase64.length);
            qtBridge.downloadPDF(pdfBase64);
        } else {
            console.error('‚ùå Qt bridge downloadPDF method not available');
            doc.save(`racing_telemetry_${new Date().toISOString().slice(0, 10)}.pdf`);
        }
        
    } catch (error) {
        console.error('‚ùå PDF generation error:', error);
        alert('Error generating PDF: ' + error.message);
        if (qtBridge && qtBridge.logMessage) {
            qtBridge.logMessage('PDF generation error: ' + error.message);
        }
    }
}

// Generate CSV for Qt integration - NEWEST FIRST
function generateCSVForQt() {
    try {
        console.log('üìä Generating CSV for Qt...');
        
        // Prepare CSV headers
        const headers = [
            'Timestamp', 'Device ID', 'Lap', 'RPM', 'Temperature', 'AFR', 'TPS', 
            'MAP Value', 'Incline', 'Stroke', 'Speed', 'Latitude', 'Longitude', 
            'Satellites', 'AI Classification', 'Cooling Active', 'Fan On', 
            'Current Temp', 'Free Heap', 'Uptime', 'WiFi RSSI'
        ];

        // Add metadata header
        const csvContent = [
            '# Racing Telemetry Data Export',
            '# Generated via Qt WebEngine Integration',
            '# Generated on: ' + new Date().toLocaleString(),
            '# Total Records: ' + allTelemetryData.length,
            '# Data Order: Newest First (Most Recent at Top)',
            '', // Empty line
            headers.join(',')
        ];
        
        // REVERSE data order - newest first
        const reversedData = allTelemetryData.slice().reverse();
        reversedData.forEach(data => {
            const row = [
                `"${new Date(data.timestamp || Date.now()).toLocaleString()}"`,
                `"${data.device_id || 'ESP32-001'}"`,
                data.lap_number || '1',
                data.sensors?.rpm || '0',
                data.sensors?.temperature || '0',
                data.sensors?.afr || '14.7',
                data.sensors?.tps || '0',
                data.sensors?.map_value || '101.3',
                data.sensors?.incline || '0',
                data.sensors?.stroke || '0',
                data.gps?.speed || '0',
                data.gps?.latitude || '0',
                data.gps?.longitude || '0',
                data.gps?.satellites || '8',
                `"${data.ai_classification?.classification_text || 'Normal'}"`,
                data.cooling?.system_active ? 'Yes' : 'No',
                data.cooling?.fan_on ? 'Yes' : 'No',
                data.cooling?.current_temp || '0',
                data.system_health?.free_heap || '50000',
                data.system_health?.uptime || '0',
                data.system_health?.wifi_rssi || '-45'
            ];
            csvContent.push(row.join(','));
        });
        
        const csvData = csvContent.join('\n');
        
        if (qtBridge && qtBridge.downloadCSV) {
            console.log('üì§ Sending CSV to Qt, length:', csvData.length);
            qtBridge.downloadCSV(csvData);
        } else {
            console.error('‚ùå Qt bridge downloadCSV method not available');
            const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', `racing_telemetry_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
    } catch (error) {
        console.error('‚ùå CSV generation error:', error);
        alert('Error generating CSV: ' + error.message);
        if (qtBridge && qtBridge.logMessage) {
            qtBridge.logMessage('CSV generation error: ' + error.message);
        }
    }
}

// Function to receive data from Qt with enhanced error handling
function updateTelemetryDataFromQt(jsonData) {
    try {
        console.log('üìä Processing telemetry data from Qt...');
        if (!jsonData) {
            console.log('‚ö†Ô∏è No data received from Qt');
            return;
        }
        
        const data = JSON.parse(jsonData);
        allTelemetryData = Array.isArray(data) ? data : [data];
        console.log('‚úÖ Updated telemetry data from Qt:', allTelemetryData.length, 'records');
        
        // Update all UI components
        if (allTelemetryData.length > 0) {
            const latestData = allTelemetryData[allTelemetryData.length - 1];
            
            // Update UI components if functions exist
            if (typeof updateCards === 'function') {
                try { updateCards(latestData); } catch(e) { console.error('Error updating cards:', e); }
            }
            if (typeof loadChartsWithHistoricalData === 'function') {
                try { loadChartsWithHistoricalData(allTelemetryData); } catch(e) { console.error('Error updating charts:', e); }
            }
            if (typeof loadTableWithData === 'function') {
                try { loadTableWithData(allTelemetryData); } catch(e) { console.error('Error updating table:', e); }
            }
            if (typeof updateFooter === 'function') {
                try { updateFooter(); } catch(e) { console.error('Error updating footer:', e); }
            }
        }
        
    } catch (error) {
        console.error('‚ùå Critical error in updateTelemetryDataFromQt:', error);
        console.error('‚ùå Stack trace:', error.stack);
        if (qtBridge && qtBridge.logMessage) {
            qtBridge.logMessage('Error parsing telemetry data: ' + error.message);
        }
    }
}

// ============================================================================
// UI FUNCTIONS
// ============================================================================

// Tab switching
function showTab(tabName) {
    // Hide all tab contents
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Remove active class from all buttons
    document.querySelectorAll('.nav-button').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Show selected tab and activate button
    const tabElement = document.getElementById(tabName + '-tab');
    const buttonElement = document.querySelector(`[data-tab="${tabName}"]`);
    
    if (tabElement) tabElement.classList.add('active');
    if (buttonElement) buttonElement.classList.add('active');
}

// Update connection status
function updateConnectionStatus(connected) {
    isConnected = connected;
    const indicator = document.getElementById('status-indicator');
    const text = document.getElementById('status-text');
    
    if (indicator && text) {
        if (connected) {
            indicator.className = 'status-dot online';
            text.textContent = 'Qt Connected';
        } else {
            indicator.className = 'status-dot offline';
            text.textContent = 'Qt Disconnected';
        }
    }
}

// ============================================================================
// TABLE FUNCTIONS - NEWEST FIRST
// ============================================================================

// Table functions
function initializeTable() {
    console.log('üìã Table initialized for Qt mode (newest first)');
}

// Modified: Insert new row at TOP
function addTableRow(data) {
    const tbody = document.getElementById('table-body');
    if (!tbody) return;
    
    const row = document.createElement('tr');
    
    row.innerHTML = `
        <td>${new Date(data.timestamp || Date.now()).toLocaleString()}</td>
        <td>${data.device_id || 'ESP32-001'}</td>
        <td>${data.lap_number || '1'}</td>
        <td>${data.sensors?.rpm || '0'}</td>
        <td>${data.sensors?.temperature || '0'}</td>
        <td>${data.sensors?.afr || '14.7'}</td>
        <td>${data.sensors?.tps || '0'}</td>
        <td>${data.sensors?.map_value || '101.3'}</td>
        <td>${data.sensors?.incline || '0'}</td>
        <td>${data.sensors?.stroke || '0'}</td>
        <td>${data.gps?.speed || '0'}</td>
        <td>${data.gps?.latitude || '0'}</td>
        <td>${data.gps?.longitude || '0'}</td>
        <td>${data.gps?.satellites || '8'}</td>
        <td>${data.ai_classification?.classification_text || 'Normal'}</td>
        <td>${data.cooling?.system_active ? 'Yes' : 'No'}</td>
        <td>${data.cooling?.fan_on ? 'Yes' : 'No'}</td>
        <td>${data.cooling?.current_temp || '0'}</td>
        <td>${formatBytes(data.system_health?.free_heap) || '50KB'}</td>
        <td>${formatUptime(data.system_health?.uptime) || '0h 0m'}</td>
        <td>${data.system_health?.wifi_rssi || '-45'}</td>
    `;
    
    // INSERT AT TOP instead of bottom
    if (tbody.firstChild) {
        tbody.insertBefore(row, tbody.firstChild);
    } else {
        tbody.appendChild(row);
    }
    
    // Keep only latest 50 rows visible (remove from bottom now)
    while (tbody.children.length > 50) {
        tbody.removeChild(tbody.lastChild);
    }
    
    // Update total records count
    const totalRecordsElement = document.getElementById('total-records');
    if (totalRecordsElement) {
        totalRecordsElement.textContent = allTelemetryData.length;
    }
}

// Modified: Load table data with newest first
function loadTableWithData(dataArray) {
    const tbody = document.getElementById('table-body');
    if (!tbody) return;
    
    tbody.innerHTML = '';
    
    // REVERSE data so newest shows first
    const reversedData = dataArray.slice().reverse();
    const recentData = reversedData.slice(0, 50); // Take latest 50
    
    // Use appendChild for bulk loading (since data is already reversed)
    recentData.forEach(data => {
        addTableRowBulk(data);
    });
}

// Helper function for bulk loading (append mode since data already reversed)
function addTableRowBulk(data) {
    const tbody = document.getElementById('table-body');
    if (!tbody) return;
    
    const row = document.createElement('tr');
    
    row.innerHTML = `
        <td>${new Date(data.timestamp || Date.now()).toLocaleString()}</td>
        <td>${data.device_id || 'ESP32-001'}</td>
        <td>${data.lap_number || '1'}</td>
        <td>${data.sensors?.rpm || '0'}</td>
        <td>${data.sensors?.temperature || '0'}</td>
        <td>${data.sensors?.afr || '14.7'}</td>
        <td>${data.sensors?.tps || '0'}</td>
        <td>${data.sensors?.map_value || '101.3'}</td>
        <td>${data.sensors?.incline || '0'}</td>
        <td>${data.sensors?.stroke || '0'}</td>
        <td>${data.gps?.speed || '0'}</td>
        <td>${data.gps?.latitude || '0'}</td>
        <td>${data.gps?.longitude || '0'}</td>
        <td>${data.gps?.satellites || '8'}</td>
        <td>${data.ai_classification?.classification_text || 'Normal'}</td>
        <td>${data.cooling?.system_active ? 'Yes' : 'No'}</td>
        <td>${data.cooling?.fan_on ? 'Yes' : 'No'}</td>
        <td>${data.cooling?.current_temp || '0'}</td>
        <td>${formatBytes(data.system_health?.free_heap) || '50KB'}</td>
        <td>${formatUptime(data.system_health?.uptime) || '0h 0m'}</td>
        <td>${data.system_health?.wifi_rssi || '-45'}</td>
    `;
    
    tbody.appendChild(row);
}

// ============================================================================
// EXPORT FUNCTIONS (Fallback for standalone mode) - NEWEST FIRST
// ============================================================================

// Export functions for standalone web mode
function exportToPDF() {
    if (allTelemetryData.length === 0) {
        alert('No data available for export');
        return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('l', 'mm', 'a4');
    
    // Add title
    doc.setFontSize(18);
    doc.text('Racing Telemetry Data Report', 14, 22);
    
    // Add generation date
    doc.setFontSize(10);
    doc.text('Generated on: ' + new Date().toLocaleString(), 14, 30);
    doc.text('Data Order: Newest First', 14, 35);
    
    // Prepare table data
    const columns = [
        'Timestamp', 'Device', 'Lap', 'RPM', 'Temp', 'AFR', 'TPS', 'MAP', 
        'Incline', 'Stroke', 'Speed', 'Lat', 'Lng', 'Sat', 'AI Class', 
        'Cooling', 'Fan', 'C.Temp', 'Heap', 'Uptime', 'RSSI'
    ];
    
    // REVERSE data order - newest first
    const reversedData = allTelemetryData.slice().reverse();
    const rows = reversedData.map(data => [
        new Date(data.timestamp || Date.now()).toLocaleString(),
        data.device_id || 'ESP32-001',
        data.lap_number || '1',
        data.sensors?.rpm || '0',
        data.sensors?.temperature || '0',
        data.sensors?.afr || '14.7',
        data.sensors?.tps || '0',
        data.sensors?.map_value || '101.3',
        data.sensors?.incline || '0',
        data.sensors?.stroke || '0',
        data.gps?.speed || '0',
        data.gps?.latitude || '0',
        data.gps?.longitude || '0',
        data.gps?.satellites || '8',
        data.ai_classification?.classification_text || 'Normal',
        data.cooling?.system_active ? 'Yes' : 'No',
        data.cooling?.fan_on ? 'Yes' : 'No',
        data.cooling?.current_temp || '0',
        formatBytes(data.system_health?.free_heap) || '50KB',
        formatUptime(data.system_health?.uptime) || '0h 0m',
        data.system_health?.wifi_rssi || '-45'
    ]);

    // Generate table
    doc.autoTable({
        head: [columns],
        body: rows,
        startY: 40,
        styles: { fontSize: 6 },
        headStyles: { 
            fillColor: [0, 150, 200],
            textColor: [255, 255, 255],
            fontStyle: 'bold'
        },
        theme: 'striped'
    });

    // Save PDF
    doc.save(`racing_telemetry_${new Date().toISOString().slice(0, 10)}.pdf`);
}

function exportToCSV() {
    if (allTelemetryData.length === 0) {
        alert('No data available for export');
        return;
    }

    // Prepare CSV headers
    const headers = [
        'Timestamp', 'Device ID', 'Lap', 'RPM', 'Temperature', 'AFR', 'TPS', 
        'MAP Value', 'Incline', 'Stroke', 'Speed', 'Latitude', 'Longitude', 
        'Satellites', 'AI Classification', 'Cooling Active', 'Fan On', 
        'Current Temp', 'Free Heap', 'Uptime', 'WiFi RSSI'
    ];

    // Add metadata and headers
    const csvContent = [
        '# Racing Telemetry Data Export',
        '# Generated on: ' + new Date().toLocaleString(),
        '# Data Order: Newest First (Most Recent at Top)',
        '',
        headers.join(',')
    ];
    
    // REVERSE data order - newest first
    const reversedData = allTelemetryData.slice().reverse();
    reversedData.forEach(data => {
        const row = [
            `"${new Date(data.timestamp || Date.now()).toLocaleString()}"`,
            `"${data.device_id || 'ESP32-001'}"`,
            data.lap_number || '1',
            data.sensors?.rpm || '0',
            data.sensors?.temperature || '0',
            data.sensors?.afr || '14.7',
            data.sensors?.tps || '0',
            data.sensors?.map_value || '101.3',
            data.sensors?.incline || '0',
            data.sensors?.stroke || '0',
            data.gps?.speed || '0',
            data.gps?.latitude || '0',
            data.gps?.longitude || '0',
            data.gps?.satellites || '8',
            `"${data.ai_classification?.classification_text || 'Normal'}"`,
            data.cooling?.system_active ? 'Yes' : 'No',
            data.cooling?.fan_on ? 'Yes' : 'No',
            data.cooling?.current_temp || '0',
            data.system_health?.free_heap || '50000',
            data.system_health?.uptime || '0',
            data.system_health?.wifi_rssi || '-45'
        ];
        csvContent.push(row.join(','));
    });

    // Create and download CSV file
    const blob = new Blob([csvContent.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    link.setAttribute('href', url);
    link.setAttribute('download', `racing_telemetry_${new Date().toISOString().slice(0, 10)}.csv`);
    link.style.visibility = 'hidden';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Utility functions
function formatBytes(bytes) {
    if (!bytes || bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function formatUptime(ms) {
    if (!ms || ms === 0) return '0h 0m';
    const seconds = Math.floor(ms / 1000);
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    return `${hours}h ${minutes}m`;
}

// Update footer
function updateFooter() {
    const lastUpdateElement = document.getElementById('last-update');
    if (lastUpdateElement) {
        lastUpdateElement.textContent = new Date().toLocaleString();
    }
    
    const totalRecordsElement = document.getElementById('total-records');
    if (totalRecordsElement) {
        totalRecordsElement.textContent = allTelemetryData.length;
    }
}

// ============================================================================
// INITIALIZATION
// ============================================================================

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ DOM Content Loaded - Qt Integration Force Mode Active');
    
    // Force check Qt integration
    checkQtIntegration();
    
    // Initialize UI components
    if (typeof initializeCards === 'function') initializeCards();
    if (typeof initializeCharts === 'function') initializeCharts();
    if (typeof initializeTable === 'function') initializeTable();
    
    // Setup export button handlers
    const exportPdfBtn = document.getElementById('export-pdf');
    const exportCsvBtn = document.getElementById('export-csv');
    
    if (exportPdfBtn) {
        exportPdfBtn.addEventListener('click', window.exportToPDF || exportToPDF);
        console.log('‚úÖ PDF export button connected to Qt function');
    }
    if (exportCsvBtn) {
        exportCsvBtn.addEventListener('click', window.exportToCSV || exportToCSV);
        console.log('‚úÖ CSV export button connected to Qt function');
    }
    
    // ALWAYS try to initialize Qt bridge with retry mechanism
    console.log('üîÑ Starting Qt WebChannel initialization...');
    
    let retryCount = 0;
    const maxRetries = 25;
    const retryDelay = 200;
    
    function tryInitQtBridge() {
        retryCount++;
        console.log(`üîÑ Qt Bridge Init Attempt: ${retryCount}/${maxRetries}`);
        
        if (typeof qt !== 'undefined' && qt.webChannelTransport && typeof QWebChannel !== 'undefined') {
            console.log('‚úÖ All Qt components ready, initializing bridge...');
            initQtBridge();
        } else if (typeof qt !== 'undefined' && typeof QWebChannel === 'undefined') {
            console.log('‚ö†Ô∏è QWebChannel missing, attempting to load...');
            loadQWebChannelScript();
        } else if (retryCount < maxRetries) {
            console.log(`‚è≥ Retrying in ${retryDelay}ms... (Missing: ${
                typeof qt === 'undefined' ? 'qt, ' : ''
            }${typeof QWebChannel === 'undefined' ? 'QWebChannel, ' : ''
            }${typeof qt !== 'undefined' && !qt.webChannelTransport ? 'transport' : ''})`);
            setTimeout(tryInitQtBridge, retryDelay);
        } else {
            console.error('‚ùå Failed to initialize Qt bridge after', maxRetries, 'attempts');
            console.log('üîç Final diagnosis:');
            console.log('  - qt object:', typeof qt);
            console.log('  - QWebChannel:', typeof QWebChannel);
            console.log('  - webChannelTransport:', typeof qt !== 'undefined' ? typeof qt.webChannelTransport : 'N/A');
        }
    }
    
    // Start initialization attempts
    setTimeout(tryInitQtBridge, 100);
});

// Add debug test button

// Error handler
window.addEventListener('error', function(event) {
    console.error('üö® Global JavaScript error:', event.error);
    if (qtBridge && qtBridge.logMessage) {
        qtBridge.logMessage('JavaScript Error: ' + event.error.message);
    }
});



// Final initialization log
console.log('üéØ JavaScript initialization complete - Qt Force Mode with Newest Data First');

    </script>

</body>
</html>
