<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Racing Telemetry Dashboard</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
    <div class="batik-pattern"></div>
    <div class="container">

        <nav class="dashboard-nav">
            <button class="nav-button active" onclick="showTab('cards')" data-tab="cards">
                <span class="nav-icon">üìä</span>
                <span class="nav-text">Cards</span>
            </button>
            <button class="nav-button" onclick="showTab('charts')" data-tab="charts">
                <span class="nav-icon">üìà</span>
                <span class="nav-text">Charts</span>
            </button>
            <button class="nav-button" onclick="showTab('table')" data-tab="table">
                <span class="nav-icon">üìã</span>
                <span class="nav-text">Data Table</span>
            </button>
               <div class="connection-status">
                    <span id="status-indicator" class="status-dot offline">‚óè</span>
                    <span id="status-text" class="status-label">Offline</span>
                </div>
        </nav>

        <!-- Cards Tab -->
        <div id="cards-tab" class="tab-content active">
            <div id="cards-container"></div>
        </div>

        <!-- Charts Tab -->
        <div id="charts-tab" class="tab-content">
            <div id="charts-container"></div>
        </div>

        <!-- Table Tab -->
        <div id="table-tab" class="tab-content">
            <div class="table-actions">
                <button id="export-pdf" class="export-btn">
                    <span>üìÑ</span> Export PDF
                </button>
                <button id="export-csv" class="export-btn">
                    <span>üìä</span> Export CSV
                </button>
            </div>
            <div class="table-container">
                <table id="data-table" class="telemetry-table">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Device ID</th>
                            <th>Lap</th>
                            <th>RPM</th>
                            <th>Temperature (¬∞C)</th>
                            <th>AFR</th>
                            <th>TPS (%)</th>
                            <th>MAP (kPa)</th>
                            <th>Incline (¬∞)</th>
                            <th>Stroke (mm)</th>
                            <th>Speed (km/h)</th>
                            <th>Latitude</th>
                            <th>Longitude</th>
                            <th>Satellites</th>
                            <th>AI Classification</th>
                            <th>Cooling Active</th>
                            <th>Fan On</th>
                            <th>Current Temp (¬∞C)</th>
                            <th>Free Heap</th>
                            <th>Uptime</th>
                            <th>WiFi RSSI</th>
                        </tr>
                    </thead>
                    <tbody id="table-body">
                        <!-- Data rows will be inserted here (NEWEST FIRST) -->
                    </tbody>
                </table>
            </div>
        </div>

        <footer class="dashboard-footer">
            <div class="footer-stats">
                <div class="footer-item">
                    <span class="footer-label">Last Update:</span>
                    <span id="last-update" class="footer-value">Never</span>
                </div>
                <div class="footer-item">
                    <span class="footer-label">Total Records:</span>
                    <span id="total-records" class="footer-value">0</span>
                </div>
            </div>
        </footer>
    </div>

    <script src="cards.js"></script>
    <script src="charts.js"></script>
<script>
// ============================================================================
// GLOBAL VARIABLES & INITIALIZATION  
// ============================================================================

// Socket.IO connection
const socket = io();

// Qt WebChannel integration
let qtBridge = null;
let isQtIntegration = false;

// Global state
let isConnected = false;
let allTelemetryData = [];

// Check for Qt integration parameter
const urlParams = new URLSearchParams(window.location.search);
isQtIntegration = urlParams.get('qt_integration') === 'true';

console.log('Running mode:', isQtIntegration ? 'Qt Integration' : 'Standalone Web');

// ============================================================================
// Qt WebChannel Integration
// ============================================================================

// Initialize Qt bridge when available
function initQtBridge() {
    if (typeof qt !== 'undefined' && qt.webChannelTransport) {
        new QWebChannel(qt.webChannelTransport, function (channel) {
            qtBridge = channel.objects.qtBridge;
            console.log('Qt bridge connected successfully');
            
            // Setup Qt-specific functionality
            setupQtExports();
            setupQtEventHandlers();
            
            // Request initial data from Qt
            if (qtBridge.requestTelemetryData) {
                qtBridge.requestTelemetryData();
            }
        });
    } else {
        console.log('Qt WebChannel not available, using Socket.IO mode');
    }
}

// Setup Qt-specific export functions
function setupQtExports() {
    if (!qtBridge) return;
    
    console.log('Setting up Qt export functions');
    
    // Override export functions for Qt integration
    window.exportToPDF = function() {
        if (allTelemetryData.length === 0) {
            alert('No data available for export');
            return;
        }
        
        console.log('Generating PDF for Qt...');
        generatePDFForQt();
    };
    
    window.exportToCSV = function() {
        if (allTelemetryData.length === 0) {
            alert('No data available for export');
            return;
        }
        
        console.log('Generating CSV for Qt...');
        generateCSVForQt();
    };
}

// Setup Qt event handlers
function setupQtEventHandlers() {
    if (!qtBridge) return;
    
    // Connect to Qt signals if available
    if (qtBridge.dataUpdated) {
        qtBridge.dataUpdated.connect(function() {
            console.log('Data updated signal received from Qt');
            // Refresh UI or request new data
            requestDataFromQt();
        });
    }
    
    // Listen for telemetry data from Qt
    if (qtBridge.telemetryDataReady) {
        qtBridge.telemetryDataReady.connect(function(jsonData) {
            console.log('Telemetry data received from Qt:', jsonData.length, 'characters');
            updateTelemetryDataFromQt(jsonData);
        });
    }
}

// Request data from Qt
function requestDataFromQt() {
    if (qtBridge && qtBridge.requestTelemetryData) {
        qtBridge.requestTelemetryData();
    }
}

// Generate PDF for Qt integration - FIXED: NEWEST FIRST
function generatePDFForQt() {
    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('l', 'mm', 'a4'); // Landscape orientation
        
        // Add title with Qt integration styling
        doc.setFontSize(20);
        doc.setTextColor(0, 150, 200); // Cyan color for Qt theme
        doc.text('Racing Telemetry Data Report', 14, 22);
        doc.setTextColor(0, 0, 0); // Reset to black
        
        // Add generation info
        doc.setFontSize(10);
        doc.text('Generated via Qt WebEngine Integration', 14, 30);
        doc.text('Generated on: ' + new Date().toLocaleString(), 14, 35);
        doc.text('Total Records: ' + allTelemetryData.length, 14, 40);
        doc.text('Data Order: Newest First (Most Recent at Top)', 14, 45);
        
        // Prepare table data
        const columns = [
            'Timestamp', 'Device', 'Lap', 'RPM', 'Temp', 'AFR', 'TPS', 'MAP', 
            'Incline', 'Stroke', 'Speed', 'Lat', 'Lng', 'Sat', 'AI Class', 
            'Cooling', 'Fan', 'C.Temp', 'Heap', 'Uptime', 'RSSI'
        ];
        
        // ‚úÖ REVERSE DATA ORDER - NEWEST FIRST
        const reversedData = allTelemetryData.slice().reverse();
        const rows = reversedData.map(data => [
            new Date(data.timestamp || Date.now()).toLocaleString(),
            data.device_id || '-',
            data.lap_number || '-',
            data.sensors?.rpm || '-',
            data.sensors?.temperature || '-',
            data.sensors?.afr || '-',
            data.sensors?.tps || '-',
            data.sensors?.map_value || '-',
            data.sensors?.incline || '-',
            data.sensors?.stroke || '-',
            data.gps?.speed || '-',
            data.gps?.latitude || '-',
            data.gps?.longitude || '-',
            data.gps?.satellites || '-',
            data.ai_classification?.classification_text || '-',
            data.cooling?.system_active ? 'Yes' : 'No',
            data.cooling?.fan_on ? 'Yes' : 'No',
            data.cooling?.current_temp || '-',
            formatBytes(data.system_health?.free_heap) || '-',
            formatUptime(data.system_health?.uptime) || '-',
            data.system_health?.wifi_rssi || '-'
        ]);

        // Generate table with Qt theme colors
        doc.autoTable({
            head: [columns],
            body: rows,
            startY: 50,
            styles: { 
                fontSize: 6,
                cellPadding: 2
            },
            headStyles: { 
                fillColor: [0, 150, 200], // Cyan theme
                textColor: [255, 255, 255],
                fontStyle: 'bold'
            },
            alternateRowStyles: {
                fillColor: [240, 248, 255] // Light cyan
            },
            theme: 'striped'
        });

        // Convert to base64 and send to Qt
        const pdfData = doc.output('datauristring').split(',')[1]; // Remove data:application/pdf;base64,
        
        if (qtBridge && qtBridge.downloadPDF) {
            qtBridge.downloadPDF(pdfData);
            console.log('PDF data sent to Qt for download (newest first)');
        } else {
            console.error('Qt bridge downloadPDF method not available');
            // Fallback to browser download
            doc.save(`racing_telemetry_${new Date().toISOString().slice(0, 10)}.pdf`);
        }
        
    } catch (error) {
        console.error('Error generating PDF:', error);
        alert('Error generating PDF: ' + error.message);
    }
}

// Generate CSV for Qt integration - FIXED: NEWEST FIRST
function generateCSVForQt() {
    try {
        // Prepare CSV headers
        const headers = [
            'Timestamp', 'Device ID', 'Lap', 'RPM', 'Temperature', 'AFR', 'TPS', 
            'MAP Value', 'Incline', 'Stroke', 'Speed', 'Latitude', 'Longitude', 
            'Satellites', 'AI Classification', 'Cooling Active', 'Fan On', 
            'Current Temp', 'Free Heap', 'Uptime', 'WiFi RSSI'
        ];

        // Add metadata header
        const csvContent = [
            '# Racing Telemetry Data Export',
            '# Generated via Qt WebEngine Integration',
            '# Generated on: ' + new Date().toLocaleString(),
            '# Total Records: ' + allTelemetryData.length,
            '# Data Order: Newest First (Most Recent at Top)',
            '', // Empty line
            headers.join(',')
        ];
        
        // ‚úÖ REVERSE DATA ORDER - NEWEST FIRST
        const reversedData = allTelemetryData.slice().reverse();
        reversedData.forEach(data => {
            const row = [
                `"${new Date(data.timestamp || Date.now()).toLocaleString()}"`,
                `"${data.device_id || ''}"`,
                data.lap_number || '',
                data.sensors?.rpm || '',
                data.sensors?.temperature || '',
                data.sensors?.afr || '',
                data.sensors?.tps || '',
                data.sensors?.map_value || '',
                data.sensors?.incline || '',
                data.sensors?.stroke || '',
                data.gps?.speed || '',
                data.gps?.latitude || '',
                data.gps?.longitude || '',
                data.gps?.satellites || '',
                `"${data.ai_classification?.classification_text || ''}"`,
                data.cooling?.system_active ? 'Yes' : 'No',
                data.cooling?.fan_on ? 'Yes' : 'No',
                data.cooling?.current_temp || '',
                data.system_health?.free_heap || '',
                data.system_health?.uptime || '',
                data.system_health?.wifi_rssi || ''
            ];
            csvContent.push(row.join(','));
        });

        const finalCsvContent = csvContent.join('\n');

        // Send CSV data to Qt
        if (qtBridge && qtBridge.downloadCSV) {
            qtBridge.downloadCSV(finalCsvContent);
            console.log('CSV data sent to Qt for download (newest first)');
        } else {
            console.error('Qt bridge downloadCSV method not available');
            // Fallback to browser download
            const blob = new Blob([finalCsvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', `racing_telemetry_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
    } catch (error) {
        console.error('Error generating CSV:', error);
        alert('Error generating CSV: ' + error.message);
    }
}

// Function to receive data from Qt
function updateTelemetryDataFromQt(jsonData) {
    try {
        const data = JSON.parse(jsonData);
        allTelemetryData = Array.isArray(data) ? data : [data];
        console.log('Updated telemetry data from Qt:', allTelemetryData.length, 'records');
        
        // Update all UI components
        if (allTelemetryData.length > 0) {
            // Update cards with latest data
            updateCards(allTelemetryData[allTelemetryData.length - 1]);
            
            // Update charts with all data
            loadChartsWithHistoricalData(allTelemetryData);
            
            // Update table with recent data - NEWEST FIRST
            loadTableWithData(allTelemetryData);
            
            // Update footer
            updateFooter();
        }
        
    } catch (error) {
        console.error('Error parsing telemetry data from Qt:', error);
        if (qtBridge && qtBridge.logMessage) {
            qtBridge.logMessage('Error parsing telemetry data: ' + error.message);
        }
    }
}

// ============================================================================
// Socket.IO Integration (for standalone web mode)
// ============================================================================

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM Content Loaded');
    
    // Initialize UI components
    initializeCards();
    initializeCharts();
    initializeTable();
    
    // Setup export button handlers
    const exportPdfBtn = document.getElementById('export-pdf');
    const exportCsvBtn = document.getElementById('export-csv');
    
    if (exportPdfBtn) {
        exportPdfBtn.addEventListener('click', isQtIntegration ? generatePDFForQt : exportToPDF);
    }
    if (exportCsvBtn) {
        exportCsvBtn.addEventListener('click', isQtIntegration ? generateCSVForQt : exportToCSV);
    }
    
    // Initialize Qt bridge or Socket.IO based on mode
    if (isQtIntegration) {
        console.log('Initializing Qt WebChannel integration...');
        setTimeout(initQtBridge, 1000); // Delay to ensure Qt is ready
    } else {
        console.log('Initializing Socket.IO mode...');
        loadHistoricalData();
    }
});

// Socket event listeners (only for standalone web mode)
if (!isQtIntegration) {
    socket.on('connect', () => {
        updateConnectionStatus(true);
        console.log('Connected to Socket.IO server');
    });

    socket.on('disconnect', () => {
        updateConnectionStatus(false);
        console.log('Disconnected from Socket.IO server');
    });

    socket.on('telemetry-update', (data) => {
        console.log('Received telemetry update via Socket.IO:', data);
        
        // Add to data array
        allTelemetryData.push(data);
        
        // Keep only latest 100 records
        if (allTelemetryData.length > 100) {
            allTelemetryData.shift();
        }
        
        updateCards(data);
        updateCharts(data);
        addTableRow(data);
        updateFooter();
    });

    socket.on('history-data', (data) => {
        console.log('Received historical data via Socket.IO:', data.length, 'records');
        allTelemetryData = data;
        loadChartsWithHistoricalData(data);
        loadTableWithData(data);
    });
}

// ============================================================================
// UI FUNCTIONS
// ============================================================================

// Tab switching
function showTab(tabName) {
    // Hide all tab contents
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Remove active class from all buttons
    document.querySelectorAll('.nav-button').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Show selected tab and activate button
    const tabElement = document.getElementById(tabName + '-tab');
    const buttonElement = document.querySelector(`[data-tab="${tabName}"]`);
    
    if (tabElement) tabElement.classList.add('active');
    if (buttonElement) buttonElement.classList.add('active');
}

// Update connection status
function updateConnectionStatus(connected) {
    isConnected = connected;
    const indicator = document.getElementById('status-indicator');
    const text = document.getElementById('status-text');
    
    if (indicator && text) {
        if (connected) {
            indicator.className = 'status-dot online';
            text.textContent = isQtIntegration ? 'Qt Connected' : 'Socket.IO Connected';
        } else {
            indicator.className = 'status-dot offline';
            text.textContent = isQtIntegration ? 'Qt Disconnected' : 'Socket.IO Disconnected';
        }
    }
}

// ============================================================================
// TABLE FUNCTIONS - FIXED: NEWEST FIRST
// ============================================================================

// Table functions
function initializeTable() {
    console.log('Table initialized for', isQtIntegration ? 'Qt mode' : 'Gateway mode');
    console.log('‚úÖ Table configured for NEWEST FIRST display');
}

// ‚úÖ FIXED: Insert new row at TOP (newest first)
function addTableRow(data) {
    const tbody = document.getElementById('table-body');
    if (!tbody) return;
    
    const row = document.createElement('tr');
    
    row.innerHTML = `
        <td>${new Date(data.timestamp || Date.now()).toLocaleString()}</td>
        <td>${data.device_id || '-'}</td>
        <td>${data.lap_number || '-'}</td>
        <td>${data.sensors?.rpm || '-'}</td>
        <td>${data.sensors?.temperature || '-'}</td>
        <td>${data.sensors?.afr || '-'}</td>
        <td>${data.sensors?.tps || '-'}</td>
        <td>${data.sensors?.map_value || '-'}</td>
        <td>${data.sensors?.incline || '-'}</td>
        <td>${data.sensors?.stroke || '-'}</td>
        <td>${data.gps?.speed || '-'}</td>
        <td>${data.gps?.latitude || '-'}</td>
        <td>${data.gps?.longitude || '-'}</td>
        <td>${data.gps?.satellites || '-'}</td>
        <td>${data.ai_classification?.classification_text || '-'}</td>
        <td>${data.cooling?.system_active ? 'Yes' : 'No'}</td>
        <td>${data.cooling?.fan_on ? 'Yes' : 'No'}</td>
        <td>${data.cooling?.current_temp || '-'}</td>
        <td>${formatBytes(data.system_health?.free_heap) || '-'}</td>
        <td>${formatUptime(data.system_health?.uptime) || '-'}</td>
        <td>${data.system_health?.wifi_rssi || '-'}</td>
    `;
    
    // ‚úÖ INSERT AT TOP (newest first)
    if (tbody.firstChild) {
        tbody.insertBefore(row, tbody.firstChild);
    } else {
        tbody.appendChild(row);
    }
    
    // Keep only latest 50 rows visible (remove from bottom)
    while (tbody.children.length > 50) {
        tbody.removeChild(tbody.lastChild);
    }
    
    // Update total records count
    const totalRecordsElement = document.getElementById('total-records');
    if (totalRecordsElement) {
        totalRecordsElement.textContent = allTelemetryData.length;
    }
}

// ‚úÖ FIXED: Load table data with NEWEST FIRST
function loadTableWithData(dataArray) {
    const tbody = document.getElementById('table-body');
    if (!tbody) return;
    
    tbody.innerHTML = '';
    
    // ‚úÖ REVERSE data array so newest shows first
    const reversedData = dataArray.slice().reverse();
    const recentData = reversedData.slice(0, 50); // Take latest 50
    
    recentData.forEach(data => {
        addTableRowBulk(data);
    });
    
    console.log(`‚úÖ Table loaded with ${recentData.length} rows (newest first)`);
}

// Helper function for bulk loading (already reversed data)
function addTableRowBulk(data) {
    const tbody = document.getElementById('table-body');
    if (!tbody) return;
    
    const row = document.createElement('tr');
    
    row.innerHTML = `
        <td>${new Date(data.timestamp || Date.now()).toLocaleString()}</td>
        <td>${data.device_id || '-'}</td>
        <td>${data.lap_number || '-'}</td>
        <td>${data.sensors?.rpm || '-'}</td>
        <td>${data.sensors?.temperature || '-'}</td>
        <td>${data.sensors?.afr || '-'}</td>
        <td>${data.sensors?.tps || '-'}</td>
        <td>${data.sensors?.map_value || '-'}</td>
        <td>${data.sensors?.incline || '-'}</td>
        <td>${data.sensors?.stroke || '-'}</td>
        <td>${data.gps?.speed || '-'}</td>
        <td>${data.gps?.latitude || '-'}</td>
        <td>${data.gps?.longitude || '-'}</td>
        <td>${data.gps?.satellites || '-'}</td>
        <td>${data.ai_classification?.classification_text || '-'}</td>
        <td>${data.cooling?.system_active ? 'Yes' : 'No'}</td>
        <td>${data.cooling?.fan_on ? 'Yes' : 'No'}</td>
        <td>${data.cooling?.current_temp || '-'}</td>
        <td>${formatBytes(data.system_health?.free_heap) || '-'}</td>
        <td>${formatUptime(data.system_health?.uptime) || '-'}</td>
        <td>${data.system_health?.wifi_rssi || '-'}</td>
    `;
    
    tbody.appendChild(row);
}

// ============================================================================
// EXPORT FUNCTIONS (Fallback for standalone web mode) - FIXED: NEWEST FIRST
// ============================================================================

// Export functions for standalone web mode
function exportToPDF() {
    if (allTelemetryData.length === 0) {
        alert('No data available for export');
        return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('l', 'mm', 'a4'); // Landscape orientation
    
    // Add title
    doc.setFontSize(18);
    doc.text('Racing Telemetry Data Report', 14, 22);
    
    // Add generation date
    doc.setFontSize(10);
    doc.text('Generated on: ' + new Date().toLocaleString(), 14, 30);
    doc.text('Data Order: Newest First (Most Recent at Top)', 14, 35);
    
    // Prepare table data
    const columns = [
        'Timestamp', 'Device', 'Lap', 'RPM', 'Temp', 'AFR', 'TPS', 'MAP', 
        'Incline', 'Stroke', 'Speed', 'Lat', 'Lng', 'Sat', 'AI Class', 
        'Cooling', 'Fan', 'C.Temp', 'Heap', 'Uptime', 'RSSI'
    ];
    
    // ‚úÖ REVERSE data order - newest first
    const reversedData = allTelemetryData.slice().reverse();
    const rows = reversedData.map(data => [
        new Date(data.timestamp || Date.now()).toLocaleString(),
        data.device_id || '-',
        data.lap_number || '-',
        data.sensors?.rpm || '-',
        data.sensors?.temperature || '-',
        data.sensors?.afr || '-',
        data.sensors?.tps || '-',
        data.sensors?.map_value || '-',
        data.sensors?.incline || '-',
        data.sensors?.stroke || '-',
        data.gps?.speed || '-',
        data.gps?.latitude || '-',
        data.gps?.longitude || '-',
        data.gps?.satellites || '-',
        data.ai_classification?.classification_text || '-',
        data.cooling?.system_active ? 'Yes' : 'No',
        data.cooling?.fan_on ? 'Yes' : 'No',
        data.cooling?.current_temp || '-',
        formatBytes(data.system_health?.free_heap) || '-',
        formatUptime(data.system_health?.uptime) || '-',
        data.system_health?.wifi_rssi || '-'
    ]);

    // Generate table
    doc.autoTable({
        head: [columns],
        body: rows,
        startY: 40,
        styles: { fontSize: 6 },
        headStyles: { 
            fillColor: [0, 150, 200], // Updated to cyan theme
            textColor: [255, 255, 255],
            fontStyle: 'bold'
        },
        theme: 'striped'
    });

    // Save PDF
    doc.save(`racing_telemetry_${new Date().toISOString().slice(0, 10)}.pdf`);
}

function exportToCSV() {
    if (allTelemetryData.length === 0) {
        alert('No data available for export');
        return;
    }

    // Prepare CSV headers
    const headers = [
        'Timestamp', 'Device ID', 'Lap', 'RPM', 'Temperature', 'AFR', 'TPS', 
        'MAP Value', 'Incline', 'Stroke', 'Speed', 'Latitude', 'Longitude', 
        'Satellites', 'AI Classification', 'Cooling Active', 'Fan On', 
        'Current Temp', 'Free Heap', 'Uptime', 'WiFi RSSI'
    ];

    // Prepare CSV rows with metadata
    const csvContent = [
        '# Racing Telemetry Data Export',
        '# Generated on: ' + new Date().toLocaleString(),
        '# Data Order: Newest First (Most Recent at Top)',
        '',
        headers.join(',')
    ];
    
    // ‚úÖ REVERSE data order - newest first
    const reversedData = allTelemetryData.slice().reverse();
    reversedData.forEach(data => {
        const row = [
            `"${new Date(data.timestamp || Date.now()).toLocaleString()}"`,
            `"${data.device_id || ''}"`,
            data.lap_number || '',
            data.sensors?.rpm || '',
            data.sensors?.temperature || '',
            data.sensors?.afr || '',
            data.sensors?.tps || '',
            data.sensors?.map_value || '',
            data.sensors?.incline || '',
            data.sensors?.stroke || '',
            data.gps?.speed || '',
            data.gps?.latitude || '',
            data.gps?.longitude || '',
            data.gps?.satellites || '',
            `"${data.ai_classification?.classification_text || ''}"`,
            data.cooling?.system_active ? 'Yes' : 'No',
            data.cooling?.fan_on ? 'Yes' : 'No',
            data.cooling?.current_temp || '',
            data.system_health?.free_heap || '',
            data.system_health?.uptime || '',
            data.system_health?.wifi_rssi || ''
        ];
        csvContent.push(row.join(','));
    });

    // Create and download CSV file
    const blob = new Blob([csvContent.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    link.setAttribute('href', url);
    link.setAttribute('download', `racing_telemetry_${new Date().toISOString().slice(0, 10)}.csv`);
    link.style.visibility = 'hidden';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Utility functions
function formatBytes(bytes) {
    if (!bytes) return '';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function formatUptime(ms) {
    if (!ms) return '';
    const seconds = Math.floor(ms / 1000);
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    return `${hours}h ${minutes}m`;
}

// Load historical data (Socket.IO mode only)
function loadHistoricalData() {
    if (!isQtIntegration && socket) {
        socket.emit('request-history', 50);
    }
}

// Update footer
function updateFooter() {
    const lastUpdateElement = document.getElementById('last-update');
    if (lastUpdateElement) {
        lastUpdateElement.textContent = new Date().toLocaleString();
    }
}

// ============================================================================
// Qt WebChannel Script Loading
// ============================================================================

// Load QWebChannel script if running in Qt
if (isQtIntegration && typeof qt !== 'undefined') {
    console.log('Loading QWebChannel script...');
    const script = document.createElement('script');
    script.src = 'qrc:///qtwebchannel/qwebchannel.js';
    script.onload = function() {
        console.log('QWebChannel script loaded, initializing bridge...');
        initQtBridge();
    };
    script.onerror = function() {
        console.error('Failed to load QWebChannel script');
    };
    document.head.appendChild(script);
} else if (isQtIntegration) {
    // Fallback initialization
    setTimeout(initQtBridge, 2000);
}

// ============================================================================
// ERROR HANDLING & DEBUGGING
// ============================================================================

// Global error handler
window.addEventListener('error', function(event) {
    console.error('Global error:', event.error);
    if (qtBridge && qtBridge.logMessage) {
        qtBridge.logMessage('JavaScript Error: ' + event.error.message);
    }
});

// Debug information
console.log('‚úÖ JavaScript initialization complete - NEWEST FIRST mode');
console.log('Mode:', isQtIntegration ? 'Qt Integration' : 'Socket.IO Standalone');
console.log('Qt object available:', typeof qt !== 'undefined');

</script>

</body>
</html>
