<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Racing Telemetry Dashboard</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
</head>

<body>
    <div class="batik-pattern"></div>
    <div class="container">

        <nav class="dashboard-nav">
            <button class="nav-button active" onclick="showTab('cards')" data-tab="cards">
                <span class="nav-icon">üìä</span>
                <span class="nav-text">Cards</span>
            </button>
            <button class="nav-button" onclick="showTab('charts')" data-tab="charts">
                <span class="nav-icon">üìà</span>
                <span class="nav-text">Charts</span>
            </button>
            <button class="nav-button" onclick="showTab('table')" data-tab="table">
                <span class="nav-icon">üìã</span>
                <span class="nav-text">Data Table</span>
            </button>
            <div class="connection-status">
                <span id="status-indicator" class="status-dot offline">‚óè</span>
                <span id="status-text" class="status-label">Offline</span>
            </div>
        </nav>

        <!-- Cards Tab -->
        <div id="cards-tab" class="tab-content active">
            <div id="cards-container"></div>
        </div>

        <!-- Charts Tab -->
        <div id="charts-tab" class="tab-content">
            <div id="charts-container"></div>
        </div>

        <!-- Table Tab -->
        <div id="table-tab" class="tab-content">
            <div class="table-actions">
                <button id="export-pdf" class="export-btn">
                    <span>üìÑ</span> Export PDF
                </button>
                <button id="export-csv" class="export-btn">
                    <span>üìä</span> Export CSV
                </button>
            </div>
            <div class="table-container">
                <table id="data-table" class="telemetry-table">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Device ID</th>
                            <th>Lap</th>
                            <th>RPM</th>
                            <th>Temperature (¬∞C)</th>
                            <th>AFR</th>
                            <th>TPS (%)</th>
                            <th>MAP (kPa)</th>
                            <th>Incline (¬∞)</th>
                            <th>Stroke (mm)</th>
                            <th>Speed (km/h)</th>
                            <th>Latitude</th>
                            <th>Longitude</th>
                            <th>Satellites</th>
                            <th>AI Classification</th>
                            <th>Cooling Active</th>
                            <th>Fan On</th>
                            <th>Current Temp (¬∞C)</th>
                            <th>Free Heap</th>
                            <th>Uptime</th>
                            <th>WiFi RSSI</th>
                        </tr>
                    </thead>
                    <tbody id="table-body">
                        <!-- Data rows will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>

        <footer class="dashboard-footer">
            <div class="footer-stats">
                <div class="footer-item">
                    <span class="footer-label">Last Update:</span>
                    <span id="last-update" class="footer-value">Never</span>
                </div>
                <div class="footer-item">
                    <span class="footer-label">Total Records:</span>
                    <span id="total-records" class="footer-value">0</span>
                </div>
            </div>
        </footer>
    </div>

    <script src="cards.js"></script>
    <script src="charts.js"></script>

    <script>
        // ============================================================================
        // GLOBAL VARIABLES & INITIALIZATION  
        // ============================================================================

        // Socket.IO connection
        const socket = io();

        // Qt WebChannel integration - FORCE ACTIVE
        let qtBridge = null;
        let isQtIntegration = true; // FORCE ALWAYS TRUE

        // Global state
        let isConnected = false;
        let allTelemetryData = [];

        console.log('üöÄ Qt Integration Mode: FORCE ACTIVATED');

        // ============================================================================
        // Qt WebChannel Integration (Complete Implementation)
        // ============================================================================

        // Enhanced Qt integration detection and initialization
        function checkQtIntegration() {
            const detectionMethods = {
                forceFlag: true,
                windowFlag: window.isQtIntegration === true,
                qtEnvironment: typeof qt !== 'undefined',
                webChannelAvailable: typeof QWebChannel !== 'undefined',
                transportAvailable: typeof qt !== 'undefined' && qt.webChannelTransport
            };

            console.log('=== Qt Integration Detection ===');
            Object.entries(detectionMethods).forEach(([key, value]) => {
                console.log(`- ${key}:`, value);
            });

            isQtIntegration = Object.values(detectionMethods).some(Boolean);
            console.log('‚úÖ Final Qt Integration Status:', isQtIntegration);

            return isQtIntegration;
        }

        // Initialize Qt bridge with comprehensive error handling
        function initQtBridge() {
            console.log('üîÑ Initializing Qt Bridge...');

            if (typeof qt === 'undefined') {
                console.error('‚ùå qt object not available');
                return;
            }

            if (!qt.webChannelTransport) {
                console.error('‚ùå qt.webChannelTransport not available');
                return;
            }

            if (typeof QWebChannel === 'undefined') {
                console.error('‚ùå QWebChannel not available, attempting to load...');
                loadQWebChannelScript();
                return;
            }

            try {
                new QWebChannel(qt.webChannelTransport, function (channel) {
                    console.log('‚úÖ QWebChannel connected successfully');
                    console.log('üìã Available objects:', Object.keys(channel.objects));

                    qtBridge = channel.objects.qtBridge;

                    if (qtBridge) {
                        console.log('‚úÖ qtBridge object connected successfully');

                        // Test connection
                        qtBridge.logMessage('üéØ JavaScript Force Mode - Successfully Connected to Qt');

                        // Setup Qt-specific functionality
                        setupQtExports();
                        setupQtEventHandlers();

                        // Update connection status
                        updateConnectionStatus(true);

                        // Request initial data
                        if (qtBridge.requestTelemetryData) {
                            console.log('üì° Requesting initial telemetry data...');
                            qtBridge.requestTelemetryData();
                        }

                    } else {
                        console.error('‚ùå qtBridge object not found in channel.objects');
                        console.log('Available objects:', channel.objects);
                    }
                });
            } catch (error) {
                console.error('‚ùå Error initializing QWebChannel:', error);
            }
        }

        // Dynamically load QWebChannel script
        function loadQWebChannelScript() {
            console.log('üì• Loading QWebChannel script dynamically...');
            const script = document.createElement('script');
            script.src = 'qrc:///qtwebchannel/qwebchannel.js';
            script.onload = function () {
                console.log('‚úÖ QWebChannel script loaded successfully');
                setTimeout(initQtBridge, 500);
            };
            script.onerror = function () {
                console.error('‚ùå Failed to load QWebChannel script');
            };
            document.head.appendChild(script);
        }

        // Setup Qt-specific export functions
        function setupQtExports() {
            if (!qtBridge) return;

            console.log('‚öôÔ∏è Setting up Qt export functions...');

            // Override export functions for Qt integration
            window.exportToPDF = function () {
                console.log('üìÑ PDF Export triggered via Qt...');
                if (allTelemetryData.length === 0) {
                    alert('‚ö†Ô∏è No data available for export');
                    return;
                }
                generatePDFForQt();
            };

            window.exportToCSV = function () {
                console.log('üìä CSV Export triggered via Qt...');
                if (allTelemetryData.length === 0) {
                    alert('‚ö†Ô∏è No data available for export');
                    return;
                }
                generateCSVForQt();
            };

            console.log('‚úÖ Qt export functions setup complete');
        }

        // Setup Qt event handlers
        function setupQtEventHandlers() {
            if (!qtBridge) return;

            console.log('üîó Setting up Qt event handlers...');

            // Connect to Qt signals
            if (qtBridge.dataUpdated) {
                qtBridge.dataUpdated.connect(function () {
                    console.log('üì° Data updated signal received from Qt');
                    requestDataFromQt();
                });
                console.log('‚úÖ dataUpdated signal connected');
            }

            // Listen for telemetry data from Qt
            if (qtBridge.telemetryDataReady) {
                qtBridge.telemetryDataReady.connect(function (jsonData) {
                    console.log('üìä Telemetry data received from Qt:', jsonData ? jsonData.length : 0, 'characters');
                    updateTelemetryDataFromQt(jsonData);
                });
                console.log('‚úÖ telemetryDataReady signal connected');
            }

            console.log('‚úÖ Qt event handlers setup complete');
        }

        // Request data from Qt
        function requestDataFromQt() {
            if (qtBridge && qtBridge.requestTelemetryData) {
                console.log('üì° Requesting telemetry data from Qt...');
                qtBridge.requestTelemetryData();
            }
        }

        // Generate PDF for Qt integration
        function generatePDFForQt() {
            try {
                console.log('üìÑ Generating PDF for Qt...');

                if (!window.jsPDF) {
                    console.error('‚ùå jsPDF library not available');
                    return;
                }

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF('l', 'mm', 'a4');

                // Add title with Qt integration styling
                doc.setFontSize(20);
                doc.setTextColor(0, 150, 200);
                doc.text('Racing Telemetry Data Report', 14, 22);
                doc.setTextColor(0, 0, 0);

                // Add generation info
                doc.setFontSize(10);
                doc.text('Generated via Qt WebEngine Integration (Force Mode)', 14, 30);
                doc.text('Generated on: ' + new Date().toLocaleString(), 14, 35);
                doc.text('Total Records: ' + allTelemetryData.length, 14, 40);

                // Prepare table data
                const columns = [
                    'Timestamp', 'Device', 'Lap', 'RPM', 'Temp', 'AFR', 'TPS', 'MAP',
                    'Incline', 'Stroke', 'Speed', 'Lat', 'Lng', 'Sat', 'AI Class',
                    'Cooling', 'Fan', 'C.Temp', 'Heap', 'Uptime', 'RSSI'
                ];

                const rows = allTelemetryData.slice(0, 100).map(data => [
                    new Date(data.timestamp || Date.now()).toLocaleString(),
                    data.device_id || '-',
                    data.lap_number || '-',
                    data.sensors?.rpm || '-',
                    data.sensors?.temperature || '-',
                    data.sensors?.afr || '-',
                    data.sensors?.tps || '-',
                    data.sensors?.map_value || '-',
                    data.sensors?.incline || '-',
                    data.sensors?.stroke || '-',
                    data.gps?.speed || '-',
                    data.gps?.latitude || '-',
                    data.gps?.longitude || '-',
                    data.gps?.satellites || '-',
                    data.ai_classification?.classification_text || '-',
                    data.cooling?.system_active ? 'Yes' : 'No',
                    data.cooling?.fan_on ? 'Yes' : 'No',
                    data.cooling?.current_temp || '-',
                    formatBytes(data.system_health?.free_heap) || '-',
                    formatUptime(data.system_health?.uptime) || '-',
                    data.system_health?.wifi_rssi || '-'
                ]);

                // Generate table
                if (window.jspdf && window.jspdf.autoTable) {
                    doc.autoTable({
                        head: [columns],
                        body: rows,
                        startY: 45,
                        styles: {
                            fontSize: 6,
                            cellPadding: 2
                        },
                        headStyles: {
                            fillColor: [0, 150, 200],
                            textColor: [255, 255, 255],
                            fontStyle: 'bold'
                        },
                        alternateRowStyles: {
                            fillColor: [240, 248, 255]
                        },
                        theme: 'striped'
                    });
                }

                // Convert to base64 and send to Qt
                const pdfData = doc.output('datauristring').split(',')[1];

                if (qtBridge && qtBridge.downloadPDF) {
                    console.log('üì§ Sending PDF data to Qt, length:', pdfData.length);
                    qtBridge.downloadPDF(pdfData);
                } else {
                    console.error('‚ùå Qt bridge downloadPDF method not available');
                    doc.save(`racing_telemetry_${new Date().toISOString().slice(0, 10)}.pdf`);
                }

            } catch (error) {
                console.error('‚ùå Error generating PDF:', error);
                alert('Error generating PDF: ' + error.message);
                if (qtBridge && qtBridge.logMessage) {
                    qtBridge.logMessage('PDF generation error: ' + error.message);
                }
            }
        }

        // Generate CSV for Qt integration
        function generateCSVForQt() {
            try {
                console.log('üìä Generating CSV for Qt...');

                // Prepare CSV headers
                const headers = [
                    'Timestamp', 'Device ID', 'Lap', 'RPM', 'Temperature', 'AFR', 'TPS',
                    'MAP Value', 'Incline', 'Stroke', 'Speed', 'Latitude', 'Longitude',
                    'Satellites', 'AI Classification', 'Cooling Active', 'Fan On',
                    'Current Temp', 'Free Heap', 'Uptime', 'WiFi RSSI'
                ];

                // Add metadata header
                const csvContent = [
                    '# Racing Telemetry Data Export',
                    '# Generated via Qt WebEngine Integration (Force Mode)',
                    '# Generated on: ' + new Date().toLocaleString(),
                    '# Total Records: ' + allTelemetryData.length,
                    '', // Empty line
                    headers.join(',')
                ];

                // Prepare CSV rows
                allTelemetryData.forEach(data => {
                    const row = [
                        `"${new Date(data.timestamp || Date.now()).toLocaleString()}"`,
                        `"${data.device_id || ''}"`,
                        data.lap_number || '',
                        data.sensors?.rpm || '',
                        data.sensors?.temperature || '',
                        data.sensors?.afr || '',
                        data.sensors?.tps || '',
                        data.sensors?.map_value || '',
                        data.sensors?.incline || '',
                        data.sensors?.stroke || '',
                        data.gps?.speed || '',
                        data.gps?.latitude || '',
                        data.gps?.longitude || '',
                        data.gps?.satellites || '',
                        `"${data.ai_classification?.classification_text || ''}"`,
                        data.cooling?.system_active ? 'Yes' : 'No',
                        data.cooling?.fan_on ? 'Yes' : 'No',
                        data.cooling?.current_temp || '',
                        data.system_health?.free_heap || '',
                        data.system_health?.uptime || '',
                        data.system_health?.wifi_rssi || ''
                    ];
                    csvContent.push(row.join(','));
                });

                const finalCsvContent = csvContent.join('\n');

                // Send CSV data to Qt
                if (qtBridge && qtBridge.downloadCSV) {
                    console.log('üì§ Sending CSV data to Qt, length:', finalCsvContent.length);
                    qtBridge.downloadCSV(finalCsvContent);
                } else {
                    console.error('‚ùå Qt bridge downloadCSV method not available');
                    // Fallback to browser download
                    const blob = new Blob([finalCsvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    const url = URL.createObjectURL(blob);

                    link.setAttribute('href', url);
                    link.setAttribute('download', `racing_telemetry_${new Date().toISOString().slice(0, 10)}.csv`);
                    link.style.visibility = 'hidden';

                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }

            } catch (error) {
                console.error('‚ùå Error generating CSV:', error);
                alert('Error generating CSV: ' + error.message);
                if (qtBridge && qtBridge.logMessage) {
                    qtBridge.logMessage('CSV generation error: ' + error.message);
                }
            }
        }

        // Function to receive data from Qt
        function updateTelemetryDataFromQt(jsonData) {
            try {
                console.log('üìä Processing telemetry data from Qt...');
                if (!jsonData) {
                    console.log('‚ö†Ô∏è No data received from Qt');
                    return;
                }

                const data = JSON.parse(jsonData);
                allTelemetryData = Array.isArray(data) ? data : [data];
                console.log('‚úÖ Updated telemetry data from Qt:', allTelemetryData.length, 'records');

                // Update all UI components
                if (allTelemetryData.length > 0) {
                    const latestData = allTelemetryData[allTelemetryData.length - 1];

                    // Update UI components if functions exist
                    if (typeof updateCards === 'function') {
                        updateCards(latestData);
                    }
                    if (typeof loadChartsWithHistoricalData === 'function') {
                        loadChartsWithHistoricalData(allTelemetryData);
                    }
                    if (typeof loadTableWithData === 'function') {
                        loadTableWithData(allTelemetryData);
                    }
                    if (typeof updateFooter === 'function') {
                        updateFooter();
                    }
                }

            } catch (error) {
                console.error('‚ùå Error parsing telemetry data from Qt:', error);
                if (qtBridge && qtBridge.logMessage) {
                    qtBridge.logMessage('Error parsing telemetry data: ' + error.message);
                }
            }
        }

        // ============================================================================
        // INITIALIZATION & EVENT HANDLING
        // ============================================================================

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function () {
            console.log('üöÄ DOM Content Loaded - Qt Integration Force Mode Active');

            // Force check Qt integration
            checkQtIntegration();

            // Initialize UI components
            if (typeof initializeCards === 'function') initializeCards();
            if (typeof initializeCharts === 'function') initializeCharts();
            if (typeof initializeTable === 'function') initializeTable();

            // Setup export button handlers
            const exportPdfBtn = document.getElementById('export-pdf');
            const exportCsvBtn = document.getElementById('export-csv');

            if (exportPdfBtn) {
                exportPdfBtn.addEventListener('click', generatePDFForQt);
                console.log('‚úÖ PDF export button connected to Qt function');
            }
            if (exportCsvBtn) {
                exportCsvBtn.addEventListener('click', generateCSVForQt);
                console.log('‚úÖ CSV export button connected to Qt function');
            }

            // Initialize Qt bridge with comprehensive retry mechanism
            console.log('üîÑ Starting Qt WebChannel initialization...');

            let retryCount = 0;
            const maxRetries = 25;
            const retryDelay = 200;

            function tryInitQtBridge() {
                retryCount++;
                console.log(`üîÑ Qt Bridge Init Attempt: ${retryCount}/${maxRetries}`);

                if (typeof qt !== 'undefined' && qt.webChannelTransport && typeof QWebChannel !== 'undefined') {
                    console.log('‚úÖ All Qt components ready, initializing bridge...');
                    initQtBridge();
                } else if (typeof qt !== 'undefined' && typeof QWebChannel === 'undefined') {
                    console.log('‚ö†Ô∏è QWebChannel missing, attempting to load...');
                    loadQWebChannelScript();
                } else if (retryCount < maxRetries) {
                    console.log(`‚è≥ Retrying in ${retryDelay}ms... (Missing: ${typeof qt === 'undefined' ? 'qt, ' : ''
                        }${typeof QWebChannel === 'undefined' ? 'QWebChannel, ' : ''
                        }${typeof qt !== 'undefined' && !qt.webChannelTransport ? 'transport' : ''})`);
                    setTimeout(tryInitQtBridge, retryDelay);
                } else {
                    console.error('‚ùå Failed to initialize Qt bridge after', maxRetries, 'attempts');
                    console.log('üîç Final diagnosis:');
                    console.log('  - qt object:', typeof qt);
                    console.log('  - QWebChannel:', typeof QWebChannel);
                    console.log('  - webChannelTransport:', typeof qt !== 'undefined' ? typeof qt.webChannelTransport : 'N/A');
                }
            }

            // Start initialization attempts
            setTimeout(tryInitQtBridge, 100);
        });

        // ============================================================================
        // UI HELPER FUNCTIONS
        // ============================================================================

        // Update connection status
        function updateConnectionStatus(connected) {
            isConnected = connected;
            const indicator = document.getElementById('status-indicator');
            const text = document.getElementById('status-text');

            if (indicator && text) {
                if (connected) {
                    indicator.className = 'status-dot online';
                    text.textContent = 'Qt Connected';
                } else {
                    indicator.className = 'status-dot offline';
                    text.textContent = 'Qt Disconnected';
                }
            }
        }

        // Utility functions
        function formatBytes(bytes) {
            if (!bytes || bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function formatUptime(ms) {
            if (!ms || ms === 0) return '0h 0m';
            const seconds = Math.floor(ms / 1000);
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${minutes}m`;
        }

        // ============================================================================
        // DEBUG & TESTING
        // ============================================================================

        // Add debug test button

        // Error handler
        window.addEventListener('error', function (event) {
            console.error('üö® Global JavaScript error:', event.error);
            if (qtBridge && qtBridge.logMessage) {
                qtBridge.logMessage('JavaScript Error: ' + event.error.message);
            }
        });

        // Add debug button after delay
        setTimeout(addDebugButton, 3000);

        // Final initialization log
        console.log('üéØ JavaScript initialization complete - Qt Force Mode Active');

    </script>


</body>

</html>